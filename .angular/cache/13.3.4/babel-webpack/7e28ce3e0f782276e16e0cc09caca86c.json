{"ast":null,"code":"import { AngularFireDatabase } from 'angularfire2/database';\nimport { from as fromPromise, of } from 'rxjs';\nimport { AuthService } from '../../account/shared/auth.service';\nimport { MessageService } from '../../messages/message.service';\nimport { ProductsUrl } from './productsUrl';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../messages/message.service\";\nimport * as i2 from \"angularfire2/database\";\nimport * as i3 from \"../../account/shared/auth.service\";\nexport let ProductRatingService = /*#__PURE__*/(() => {\n  class ProductRatingService {\n    constructor(messageService, angularFireDatabase, authService) {\n      this.messageService = messageService;\n      this.angularFireDatabase = angularFireDatabase;\n      this.authService = authService;\n      this.productsUrl = ProductsUrl.productsUrl;\n      this.authService.user.subscribe(user => this.user = user);\n    }\n    /** Log a ProductService message with the MessageService */\n\n\n    log(message) {\n      this.messageService.add('ProductService: ' + message);\n    }\n    /**\r\n     * Handle Http operation that failed.\r\n     * Let the app continue.\r\n     * @param operation - name of the operation that failed\r\n     * @param result - optional value to return as the observable result\r\n     */\n\n\n    handleError(operation = 'operation', result) {\n      return error => {\n        console.error(error); // log to console instead\n\n        this.log(`${operation} failed: ${error.message}`); // Let the app keep running by returning an empty result.\n\n        return of(result);\n      };\n    }\n\n    rateProduct(product, rating) {\n      const url = `${this.productsUrl}/${product.id}`;\n      const updates = this.constructRating(product, rating);\n      return fromPromise(this.angularFireDatabase.object(url).update(updates).then(() => this.log(`Rated Product ${product.name} width: ${rating}`)).catch(error => {\n        this.handleError(error);\n      }));\n    } // pure helper functions start here\n\n\n    constructRating(product, rating) {\n      // construct container for update content\n      const updates = {}; // Add user rating to local version of ratings\n\n      if (product.ratings) {\n        product.ratings[this.user.uid] = rating;\n      } else {\n        product['ratings'] = [];\n        product['ratings'][this.user.uid] = rating;\n      } // Add user rating\n\n\n      updates['/ratings/' + this.user.uid + '/'] = rating; // calculate current overall rating\n\n      updates['/currentRating/'] = this.calculateOverallRating(product, rating);\n      return updates;\n    }\n\n    calculateOverallRating(product, rating) {\n      // Calculate and add new overall rating\n      const currentRating = Object.values(product.ratings).reduce((a, b) => a + b, 0) / Object.values(product.ratings).length;\n      return currentRating;\n    }\n\n  }\n\n  ProductRatingService.ɵfac = function ProductRatingService_Factory(t) {\n    return new (t || ProductRatingService)(i0.ɵɵinject(i1.MessageService), i0.ɵɵinject(i2.AngularFireDatabase), i0.ɵɵinject(i3.AuthService));\n  };\n\n  ProductRatingService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ProductRatingService,\n    factory: ProductRatingService.ɵfac\n  });\n  return ProductRatingService;\n})();","map":null,"metadata":{},"sourceType":"module"}