{"ast":null,"code":"import { combineLatest as observableCombineLatest, from as fromPromise, of } from 'rxjs';\nimport { catchError, tap, switchMap, map } from 'rxjs/operators';\nimport { AngularFireDatabase } from 'angularfire2/database';\nimport { AuthService } from '../../account/shared/auth.service';\nimport { FileUploadService } from './file-upload.service';\nimport { MessageService } from '../../messages/message.service';\nimport { ProductRatingService } from './product-rating.service';\nimport { ProductsUrl } from './productsUrl';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../messages/message.service\";\nimport * as i2 from \"angularfire2/database\";\nimport * as i3 from \"../../account/shared/auth.service\";\nimport * as i4 from \"./file-upload.service\";\nimport * as i5 from \"./product-rating.service\";\nexport let ProductService = /*#__PURE__*/(() => {\n  class ProductService {\n    constructor(messageService, angularFireDatabase, authService, uploadService, productRatingService) {\n      this.messageService = messageService;\n      this.angularFireDatabase = angularFireDatabase;\n      this.authService = authService;\n      this.uploadService = uploadService;\n      this.productRatingService = productRatingService;\n      this.productsUrl = ProductsUrl.productsUrl;\n    }\n    /** Log a ProductService message with the MessageService */\n\n\n    log(message) {\n      this.messageService.add('ProductService: ' + message);\n    }\n    /**\r\n     * Handle Http operation that failed.\r\n     * Let the app continue.\r\n     * @param operation - name of the operation that failed\r\n     * @param result - optional value to return as the observable result\r\n     */\n\n\n    handleError(operation = 'operation', result) {\n      return error => {\n        console.error(error); // log to console instead\n\n        this.log(`${operation} failed: ${error.message}`); // Let the app keep running by returning an empty result.\n\n        return of(result);\n      };\n    }\n\n    getProducts() {\n      return this.angularFireDatabase.list('products', ref => ref.orderByChild('date')).valueChanges().pipe(map(arr => arr.reverse()), catchError(this.handleError(`getProducts`)));\n    }\n\n    getProductsQuery(byChild, equalTo, limitToFirst) {\n      return this.angularFireDatabase.list('products', ref => ref.orderByChild(byChild).equalTo(equalTo).limitToFirst(limitToFirst)).valueChanges().pipe(catchError(this.handleError(`getProductsQuery`)));\n    }\n\n    findProducts(term) {\n      return this.angularFireDatabase.list('products', ref => ref.orderByChild('name').startAt(term).endAt(term + '\\uf8ff')).valueChanges().pipe(catchError(this.handleError(`getProductsQuery`)));\n    }\n\n    getProductsByDate(limitToLast) {\n      return this.angularFireDatabase.list('products', ref => ref.orderByChild('date').limitToLast(limitToLast)).valueChanges().pipe(map(arr => arr.reverse()), catchError(this.handleError(`getProductsByDate`)));\n    }\n\n    getProductsByRating(limitToLast) {\n      return this.angularFireDatabase.list('products', ref => ref.orderByChild('currentRating').limitToLast(limitToLast)).valueChanges().pipe(map(arr => arr.reverse()), catchError(this.handleError(`getProductsByRating`)));\n    }\n\n    getFeaturedProducts() {\n      return this.angularFireDatabase.list('featured').snapshotChanges().pipe(switchMap(actions => {\n        return observableCombineLatest(actions.map(action => this.getProduct(action.key)));\n      }, (actionsFromSource, resolvedProducts) => {\n        resolvedProducts.map((product, i) => {\n          product['imageFeaturedUrl'] = actionsFromSource[i].payload.val().imageFeaturedUrl;\n          return product;\n        });\n        return resolvedProducts;\n      }), catchError(this.handleError(`getFeaturedProducts`)));\n    }\n\n    getProduct(id) {\n      const url = `${this.productsUrl}/${id}`;\n      return this.angularFireDatabase.object(url).valueChanges().pipe(tap(result => {\n        if (result) {\n          return of(result);\n        } else {\n          this.messageService.addError(`Found no Product with id=${id}`);\n          return of(null);\n        }\n      }), catchError(this.handleError(`getProduct id=${id}`)));\n    }\n\n    updateProduct(data) {\n      const url = `${this.productsUrl}/${data.product.id}`;\n\n      if (!data.files.length) {\n        return this.updateProductWithoutNewImage(data.product, url);\n      }\n\n      const dbOperation = this.uploadService.startUpload(data).then(task => {\n        data.product.imageURLs[0] = task.downloadURL;\n        data.product.imageRefs[0] = task.ref.fullPath;\n        return data;\n      }).then(dataWithImagePath => {\n        return this.angularFireDatabase.object(url).update(data.product);\n      }).then(response => {\n        this.log(`Updated Product ${data.product.name}`);\n        return data.product;\n      }).catch(error => {\n        this.handleError(error);\n        return error;\n      });\n      return fromPromise(dbOperation);\n    }\n\n    updateProductWithoutNewImage(product, url) {\n      const dbOperation = this.angularFireDatabase.object(url).update(product).then(response => {\n        this.log(`Updated Product ${product.name}`);\n        return product;\n      }).catch(error => {\n        this.handleError(error);\n        return error;\n      });\n      return fromPromise(dbOperation);\n    }\n\n    addProduct(data) {\n      const dbOperation = this.uploadService.startUpload(data).then(task => {\n        data.product.imageURLs.push(task.downloadURL);\n        data.product.imageRefs.push(task.ref.fullPath);\n        return this.angularFireDatabase.list('products').set(data.product.id.toString(), data.product);\n      }, error => error).then(response => {\n        this.log(`Added Product ${data.product.name}`);\n        return data.product;\n      }).catch(error => {\n        this.messageService.addError(`Add Failed, Product ${data.product.name}`);\n        this.handleError(error);\n        return error;\n      });\n      return fromPromise(dbOperation);\n    }\n\n    deleteProduct(product) {\n      const url = `${this.productsUrl}/${product.id}`;\n      this.uploadService.deleteFile(product.imageRefs);\n      return this.angularFireDatabase.object(url).remove().then(() => this.log('success deleting' + product.name)).catch(error => {\n        this.messageService.addError('Delete failed ' + product.name);\n        this.handleError('delete product');\n      });\n    }\n\n  }\n\n  ProductService.ɵfac = function ProductService_Factory(t) {\n    return new (t || ProductService)(i0.ɵɵinject(i1.MessageService), i0.ɵɵinject(i2.AngularFireDatabase), i0.ɵɵinject(i3.AuthService), i0.ɵɵinject(i4.FileUploadService), i0.ɵɵinject(i5.ProductRatingService));\n  };\n\n  ProductService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ProductService,\n    factory: ProductService.ɵfac\n  });\n  return ProductService;\n})();","map":null,"metadata":{},"sourceType":"module"}